\chapter{Background and Theory}
% This chapter should describe the theoretical background needed to understand and solve the problem. 
% For instance, a description of the hardware platform or specific components involved in this assignment, definition of concepts that are important to understand the solution should be summarized here.
% Add citations to show sources whenever appropriate, LaTeX and bibliography managers make this easy. For instance, ``I always thought something was fundamentally wrong with the universe'' \cite{adams1995hitchhiker}.


% TODO: Kanskje ha en generell introduksjon til selve kortet?
\section{ARM Cortex-M3}
As a part of the EFM32GG-DK3750, the ARM Cortex-M3 is a 32-bit RISC processor combining high performance and excellent response time with low cost and power consumption. Among its notable features is a Harvard Architecture, the Thumb-2 instruction set, and efficient 32-bit multiplication and division.

\subsection{Processor mode and privilege levels}
The Cortex-M3 can run software at two privilege levels: privileged and unprivileged. The privilege levels are used by the processor hardware to restrict running software to certain resources only. This is necessary in order to provide memory protection, for instance. In privileged mode, running software has access to all instructions and resources, while in unprivileged mode access is restricted. The software privilege level depends on wether the processor is running in \emph{thread mode} or \emph{handler mode}. In thread mode the software runs at either privileged or unprivileged level depending on the CONTROL register, while in handler mode the software always runs at the privileged level.

The processor will switch from thread mode to handler mode on any exception. This allows the interrupt handlers to use all instructions and access all memory. In an operating system, kernel code would run in handler mode and user space programs would run in thread mode.\cite{CortexM3-RM}

\subsection{Registers}
The Cortex-M3 makes several registers visible to the programmer. These include the general-purpose registers R0 through R12, the Stack Pointer (SP/R13), the Link Register (LR/R14), the Program Counter (PC/R15), and the Program Status Register (PSR). 

\subsubsection{General-purpose registers}
ARM Cortex-M3 contians 13, 32-bit general purpose registers, labled R0-R12. When an exception occurs the CPU automatically pushes the registers R0-R3 to the stack. Registers R4-R12 have to be handled manually.

\subsubsection{Stack Pointer (SP)}
Register R13 is reserved for the stack pointer. SP is used to point to the last stacked item in the stack memory. The processor contains two stacks, the \emph{main stack} and the \emph{process stack}. In Thread mode the control registers second bit indicates which stack pointer to use.

\begin{itemize}
\item 0 = Main Stack Pointer
\item 1 = Process Stack pointer
\end{itemize}

\subsubsection{Link Register (LR)}
LR is register R14 and is used to store information about subrutines, function calls and excepitons.

\subsubsection{Program Counter (PC)}
PC is register R15. PC holds address for the current program. Since instructions has to be halfword aligned the first bit is allways 0. When the processor is reset, the PC loads the default value from the reset vector. 

\subsubsection{Program Status Register (PSR)}
The PSR is used to stored states after an instruction. E.g. the add instruction may produce overflow and bit[28] indicates if the operation resulted in overflow. PSR's bit assigments can bee seen in the figures chapter \ref{fig:PSRMap}.

\subsection{NVIC}
The Cortex-M3 comes with an NVIC, a Nested Vectored Interrupt Controller, which allows us to execute code whenever an interrupt is registered. When an interrupt is registered the NVIC will jump to a memory address specified in its interrupt vector table (TODO: Link to fig vectors) which holds the address of an interrupt handler that should be run when the interrupt is triggered.\cite{compendium}

Upon a reset, the processor will start executing the reset handler in handler mode. When the reset handler returns, it will return to thread mode.

\section{On-board components and peripherals}

Through the exercises in this course we will work with the  Silicon labs EFM32GG-DK3750 prototyping board \ref{fig:EFMBoard}. There are several on-board components and peripherals of special interest, including the General-Purpose Input/Output pins (GPIO pins) controlling external peripheral devices, the gamepad prototype, the Clock Management Unit (CMU), the Energy Management Unit (EMU), the LCD screen outputting current amperage, and the wires connecting the board to the development PC. These components however are just a small subset of the peripherals offered, so we have provided a map of the full set of peripherals \ref{fig:GiantGeckoMap}.

\subsection{General-Purpose Input/Output pins}
The GPIO pins is what makes it possible to connect external peripherals to the EFM32GG prototyping board. The pins are organized into ports of 16 pins each. It is possible to configure each pin individually for either input or output, in addition to configuring more advanced features such as drive-strength or pull-up resistors.

\subsection{The gamepad}
The gamepad peripheral is connected to the GPIO pins on port A and C using a Y-shaped ribbon cable. It has eight buttons and eight LEDs connecting the pins to ground, making it possible to provide both input and output. In addition, the gamepad also has a jumper which allows us to toggle whether the amperage consumed by the LEDs will be measured.

\subsection{Clock Management Unit}
The CMU controls on-board oscillators and clocks. These components consume a significant amount of power, as a clock signal needs to be generated for all active on-board peripherals. The CMU provides a high level of configurability, allowing the clocks to be turned on and off on an individual basis. By default, the clocks for all components are turned off, and need to be manually enabled for the components that will be used.\cite{EFM32GG-RM}

\subsection{Energy Management Unit}
The EMU manages the different low energy modes in the EFM32GG. Being a microcontroller with focus on energy efficiency, the EFM32GG has five distinct energy modes, from EM0 (run mode) where the CPU and all peripherals are active, to EM4 where the CPU and most peripherals are disabled. What components are active on different modes is detailed in \ref{fig:GiantGeckoMap}. In addition to handling the energy modes, the EMU can be used to turn off the power to unused SRAM blocks.\cite{EFM32GG-RM}


\section{Energy consumption}

When reasoning about the expenditure of a device it’s useful to break down energy consumption into static and dynamic consumption. Dynamic consumption is the power consumed as a function of clock rate. A processor running at a higher clock rate will in general expend more energy. The static consumption is the energy a device consumes regardless of clock frequency, for instance the small current that keeps SRAM from flipping over when not in use.

TODO: Here I want the picture from the energy optimization PDF when we migrate to tex.

In this task the main challenge is to reduce both static and dynamic power consumption to a bare minimum while still providing the necessary services for the buttons and LEDs to work.



\section{Memory}

\subsection{Memory-mapped I/O}
The EFM32GG uses memory-mapped I/O. With memory-mapped I/O, a range of memory addresses is mapped onto device registers. This means that the registers can be read and written using ordinary load/store instructions. All configuration of the EFM32GG is done by writing to memory-mapped registers.\cite{EFM32GG-RM}

In order to control the gamepad and the board components, we use memory-mapped I/O to read and write different registers. For instance the GPIO pins are configured with the addresses starting at 0x40006000, and the CMU is configured with the addresses starting at 0x400c8000.

% TODO: See if this section should be used
% \subsection{Accessing device registers}
% Some device registers are only one byte long, but there is no instruction that writes a single byte to memory. When writing to such registers, we need to take special care so that the correct byte is written to, and so that unrelated bytes are not overwritten. For instance when we configure the LEDs we need to shift the input bits one byte to the left, and when disabling SRAM we need to use XOR to not overwrite the rest of the register.

\subsection{Register addressing}
We specify registers with their base address followed by their offsets. The base address marks the start of a memory segment dedicated to a certain functionality. In the text we will refer directly to the memory address of a functionality using its symbolic name as specified in the reference manual. For instance, EMU\_MEM\_CTRL refers to the 32 bits that control memory handling in various energy modes. However in the code we will have to compute the memory addresses by adding an offset to the base address of a functionality.



\section{Tools}

\subsection{GNU toolchain}
The GNU toolchain is a collection of programming tools used for software development. The GNU toolchain is produced by the GNU project and is free software. The components of the GNU toolchain used in this course are make (build-automation tool), ld (linker), as (assembler), and the GNU debugger.\cite{gnu.org}
% TODO (optional): Skrive litt om de forskjellige verktøyene

% TODO: Flytte de to neste avsnittene inn et sted hvor de passer
Instruction fetching
What is an instruction set? How does the microprocessor fetch instructions?

Thumb-2 instruction set
The Thumb-2 instruction set is a 32-bit instruction set used for ARM microprocessors. It is an extension of the older 16-bit Thumb instruction set, and contains a mix of both 16-bit and 32-bit instructions. The additional 32-bit instructions allow it to cover the functionality of newer ARM microprocessors, (http://infocenter.arm.com/help/index.jsp section 2.2).
