\chapter{Methodology}
% This chapter should discuss the details of your implementation for the
% assignment. Everything related to how things were done should go here.
% Remember to avoid going into too much details, summarize appropriately and
% try to use figures/charts. Make sure you refer to the figures (such as Figure
% \ref{fig:universe}) and charts you add in the text. Avoid putting lots of
% source code here -- small code snippets are fine if you want to discuss
% something specific.


\section{Sleeping between interrupts}
While a song is playing the board recieves 32.768 interrupts each second. In the time between interrupts we can place the board in sleep mode.
% TODO: Put this section somewhere appropriate
% TODO: Write about how using interrupts to sleep between each sample written to the DAC saves energy

\section{Using a low frequency timer}
% TODO: Put this section somewhere appropriate
As a considerable energy reduction was achieved by entering by entering energy mode EM1 after writing samples to the DAC, it was natural to think that entering EM2 would lower the energy reduction even further. One issue that occurred while implementing this functionality, is that the TIMER used to generate interrupts for the microcontroller is only available in energy modes EM0 and EM1. Thus if the microcontroller is to enter EM2 or lower energy modes, a different source of interupts is needed. The EFM32GG implements this functionality with the LETIMER module introduced in section \ref{sec:letimer}. 

In order to use the LETIMER, we configured the CMU through the following steps:
\begin{itemize}
  \item Starting the Low Frequency Oscillator LFXO by writing 1 to the LFXO bit in CMU\_OSCENCMD.
  \item Setting LFXO as a clock source for the LFACLK clock by writing 0 to the LFA bits in CMU\_LFCLKSEL.
  \item Enabling the LFACLK clock for the LETIMER by setting the LETIMER0 bit in CMU\_LFACLKEN0.
  \item Enabling the clock for the low energy peripheral interface by setting the LE bit in CMU\_HFCORECLKEN0.
\end{itemize}

% TODO: Explain how we needed to configure the registers
\subsection{Clock accuracy}
We first used the LFRCO clock as a timer. With LFRCO we often recieved impure sounds. This was most likely due inaccuracy. It seems that we had no guarantee that the frequency was excactly 32.768 Hz. As a result we changed to LFXO, which gave much better sounds.

\section{Saving song in memory}
Our first thougt was to save all the samples of a song. A normal song is sampled at 44100 Hz and each sample is n. One second of a normal song takes about 86 KB. However, the EFM32 board has a limited amount of memory. We could have managed to represent a few seconds of high quality sound with optimizations. 

In our solution we chose to represent a song as an array of 16 bit int values. Inside these 16 bits we store information about pitch, octave, amplitude and duration. In table \ref{tab:bitFields} the bit partitions are described. \\

\begin{table}[ht]
	\begin{center}
	\begin{tabular}{ |c|c|c|c| }
	  \hline
	  Pitch & Octave & Amplitude & Duration \\
	  \hline
	  4 & 4 & 3 & 5 \\
	  \hline

	\end{tabular}
	\caption{Bit partitioning}
	\label{tab:bitFields}
	\end{center}
\end{table}

Each pitch value is represented by a value from 0 to 11. The Octave can take the values 0-10. Note A with octave 0 is lowest possible at 27.5 Hz, and note A with octave 10 the highest at 28160 Hz. DAC's lowest values is to low hear, beacuse of this we calculated the amplitude with the equation \ref{eq:amplitudCalculation}. In addition we only had 3 bit to store the amplitude values, and as a result we calculated the exponentially. Duration takes values between 0-32. In our program we define the duration of the shortest note. The duration value is multiplied with the defined duration value and returns each notes duration given in milliseconds. By changing the defined duration value we can increase or decrease the song's speed.

\begin{equation}
  x = 2^{amplitude + 5}
  \label{eq:amplitudCalculation}
\end{equation}

\section{Testing}
% Add content in this section that describes how you tested and verified the
% correctness of your implementation, with respect to the requirements of the
% assignment.

\section{Optimization}

