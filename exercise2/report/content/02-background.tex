\chapter{Background and Theory}
% This chapter should describe the theoretical background needed to understand
% and solve the problem. For instance, a description of the hardware platform
% or specific components involved in this assignment, definition of concepts
% that are important to understand the solution should be summarized here. Add
% citations to show sources whenever appropriate.


\section{Direct Memory Access}
Direct Memory Access (DMA) is a technique in which I/O devices use the CPU bus to access the memory directly without involving the CPU. 

% TODO: Possibly mention how CPU wants to do other things

This is usually achieved by having a DMA controller, a specialized hardware component that can transfer data between memory and I/O devices, without direct interaction from the CPU. The I/O devices will be unaware that the transfer is being done by the DMA controller and not the CPU. An alternative to using a DMA controller for I/O is to do programmed input/output, where the CPU either uses interrupts or busy-wait to continually service an I/O device. DMA usually benefits over this approach as it allows the CPU to perform other work, or to enter low energy modes. It is possible to run the DMA in EM2 by using the LEUART module (see section \ref{subsec:leuart}).

% TODO: Mention bus clogging and CPU idling

The DMA controller has 12 independent \emph{channels}. These can be triggered from either peripherals or software to start a DMA cycle. During a cycle, the DMA controller will read a \emph{channel descriptor} from system memory corresponding to that channel(?), and perform one or more DMA transfers as specified by the channel descriptor (and the DMA configuration?).

\subsection{Channel Configuration}
Before using a peripheral module together with the controller, a DMA channel must be configured to receive that peripheral's requests. This is done by writing to the channel control registers DMA\_CHx\_CTRL. These registers have two components: SOURCESEL, used to select which peripheral to listen to, and SIGSEL that specifies the signal to listen to of that peripheral.

\subsection{DMA Cycles}
A DMA cycle consists of several DMA transfers in which the controller transfers a single byte or word from one memory location to another. The controller might need several cycles in order to completely service a request. The behaviour of the controller during a cycle must be specified in the channel descriptor by setting a cycle type in the cycle\_ctrl bits.

\subsection{Channel Descriptors}
Channel descriptors are used to configure the behaviour of the DMA controller during a single DMA cycle. The channel descriptors must be stored in a contiguous area of memory called the \emph{channel control data structure}. The channel controll data structure itself consists of a primary and an alternate data structure, and these are lists of channel descriptors. It is the responsibility of the software to allocate the channel control data structures, and to write the channel descriptors needed. In addition, the base address of the channel control data structure needs to be written to the controller register DMA\_CTRLBASE. When reading the channel control data structure, the controller uses the lower eight bits to address channel descriptors. For this reason, the base address of the data structure must be at an address like 0xXXXXXX00.

A channel descriptor contains the following elements:
\begin{itemize}
	\item src\_data\_end\_ptr, a pointer to the ending address of the source data.
	\item dst\_data\_end\_ptr, a pointer to the ending address of the destination data.
	\item channel\_cfg, provides control information such as cycle type and R\_power.
\end{itemize}
At the start of a DMA cycle, the controller will read the channel\_cfg from memory. After completing the cycle, an updated channel\_cfg will be written back.


\section{On-board components and peripherals}
Through the exercises in this course we will work with the Silicon labs EFM32GG-DK3750 prototyping board \ref{fig:EFMBoard}. There are several on-board components and peripherals of special interest, including the General-Purpose Input/Output pins (GPIO pins) controlling external peripheral devices, the gamepad prototype, the Clock Management Unit (CMU), and the Energy Management Unit (EMU). This section will give a brief introduction to those devices. For a map of the full set of peripherals, see figure \ref{fig:GiantGeckoMap}.


\subsection{Clock Management Unit}\label{subsec:cmu}
The Clock Management Unit (CMU) controls the on-board oscillators and clocks, and produces clock signals that drives the core modules and all the peripherals. The CMU can enable or disable clock signals for the peripherals on an individual basis, and the power consumption is reduced significantly by only enabling the clock for the peripherals that will be used. By default, the clock for all peripherals is disabled. 

The CMU manages several system clocks in order to provide different clock signals to the core modules and the peripherals. These system clocks include the High Frequency Clock (HFCLK), the High Frequency Core Clock (HFCORECLK), and the High Frequency Peripheral Clock (HFPERCLK).\cite{efm32gg-rm}

\subsubsection{High Frequency Clock}
HFCLK drives two prescalers that generate HFCORECLK and HFPERCLK, in addition to driving the CMU itself. With separate prescalers it is possible to configure the clock speeds of the core modules and the peripherals individually. The HFCLK itself can be driven either by one of the high-frequency oscillators (HFRCO and HFXO), or by one of the low-frequency oscillators (LFRCO and LFXO). 

\subsubsection{High Frequency Core Clock}
HFCORECLK is the clock that drives the core modules, which consists of the CPU and tightly coupled modules such as the DMA. The frequency of HFCORECLK can be changed dynamically by writing to CMU\_HFCORECLKDIV, and the clock can be disabled for individual modules by clearing bits in CMU\_HFCORECLKEN0. 

\subsubsection{High Frequency Peripheral Clock}
HFPERCLK is the clock that drives the high-frequency peripherals. The frequency of the HFPERCLK can be changed dynamically by writing to CMU\_HFPERCLKDIV, and the clock can be disabled for individual peripherals by clearing bits in CMU\_HFPERCLKEN0. 

%TODO: Write about other clocks

\subsubsection{Oscilliators}
TODO % TODO: Write about oscilliators

\subsection{General-Purpose Input/Output pins}
The General-Purpose Input/output (GPIO) pins is what makes it possible to connect external peripherals to the EFM32GG prototyping board. The pins are organized into ports of 16 pins each. It is possible to configure each pin individually for either input or output, in addition to configuring more advanced features such as drive-strength or pull-up resistors.


\subsection{The Gamepad}
The gamepad peripheral is connected to the GPIO pins on port A and C using a Y-shaped ribbon cable. It has eight buttons and eight LEDs connecting the pins to ground, making it possible to provide both input and output. In addition, the gamepad also has a jumper which allows us to toggle whether the amperage consumed by the LEDs will be measured.


\subsection{Peripheral Reflex System}
The Peripheral Reflex System (PRS) is a network connecting the different peripheral modules together, allowing them to communicate directly without involving the CPU. The peripheral modules send each other \emph{reflex signals} routed by the PRS. On receiving such a signal, a peripheral module may perform some specific action depending on the signal received. By relieving the CPU of work, the PRS system can be used to improve energy efficiency. It is also suited for time-critical operations as it involves no variable-time software overhead.


\subsection{TIMER (Timer/Counter)}
The TIMER module can be used to count events and trigger actions in other peripherals without involving the CPU. It can also be used to trigger interrupts after a specific time interval. It has a 16 bit counter that is either incremented or decremented depending on the \emph{counter mode} of the timer.

\subsubsection{Source Clock and Prescaling} The peripheral clock HFPERCLK can be used as a source clock to drive the counter. It runs at the prescaled frequency of the high frequency clock HFCLK (see section \ref{subsec:cmu}), and this can be further prescaled in the TIMER module by setting the PRESC bits in TIMERn\_CTRL to an integer $n$ between 0 and 10. The resulting frequency of which the timer is updated is HFPERCLK divided by $2^{n}$.
%TODO: Write about other source clocks for the timer

\subsubsection{Operation}
The timer can be started and stopped by writing to the bits START and STOP in the register TIMERn\_CMD. However, it is also possible to control the timer from other peripherals through the PRS.

\subsubsection{Counter Modes}
The timer has four different modes:
\begin{enumerate}
	\item Up-count: The timer starts at 0, counts upwards, and resets to 0 when reaching the value of TIMER\_n\_TOP.
	\item Down-count: The timer starts at TIMER\_n\_TOP, counts downwards, and resets to the value of TIMER\_n\_TOP when reaching 0.

	\item Up/Down-count: TODO % TODO
	\item Quadrature Decoder: TODO % TODO
\end{enumerate}


\subsection{Digital-to-Analog Converter}
% TODO

The Digital-to-Analog Converter (DAC) converts digital values to analog signals. The digital values are fed into the DAC through the two 12-bit input channels DACn\_CH0DATA and DACn\_CH1DATA, and is converted to output voltages on the two output channels. By feeding the output from the DAC through the on-board amplifier and into external speakers, the EFM32GG can be used to create sounds.

TODO % TODO 


\subsection{Low Energy Universal Asynchronous Receiver/Transmitter}\label{subsec:leuart}
TODO % TODO

\subsection{Energy Management Unit (EMU)}\label{sec:emu}
The EMU manages the different low energy modes in the EFM32GG. Being a MCU with focus on energy efficiency, the Cortex-M3 has five distinct energy modes, from EM0 (run mode) where the CPU and all peripherals are active, to EM4 where the CPU and most peripherals are disabled. What components are active on different modes is detailed in figure \ref{fig:GiantGeckoMap}. In addition to handling the energy modes, the EMU can be used to turn off the power to unused SRAM blocks.\cite{efm32gg-rm}

\subsubsection{Disabling RAM blocks}
TODO % TODO: Explain how to disable RAM blocks


\section{Energy Consumption}
This section gives a brief overview of several ways to reduce the static and dynamic power consumption in the EFM32GG.
% Use?: The two main approaches is to limit the power spent at a given moment, and to reduce the time spent in high energy modes.

\subsection{Static and dynamic power}
% TODO: Read through chapter 3 in energy-optimization note and apply what's there to this section
The power used by a CMOS integrated circuit can be split into two main parts: \emph{static power} and \emph{dynamic power}. Static power is power used regardless of whether the circuit is changing states or not, for instance the small current that keeps SRAM from flipping over when not in use. Dynamic power is the additional power used when the circuit changes states. In clocked circuits the dynamic power used is proportional to the clock rate. As an example, a processor running at a higher clock rate will in general use more power per unit of time.\cite{efm32-energy-optimization}
% Static power can be determined by the formula P_{static} = I_{static}V_{dd}

% Probably will not be used
%
%\subsection{Power management strategies}
%In the course literature, two strategies for power management are described: \emph{dynamic} and \emph{static}. It is important to note that these bear no direct relation to static and dynamic power dissipation. 


\subsection{Reducing energy consumption in the EFM32GG}

\subsubsection{Disabling RAM Blocks}
In the EFM32GG there is a static power dissipation in the RAM blocks of approximately 170 nA per 32 KB block. This constitutes a considerable amount when the device is in EM2 or EM3 energy modes. The RAM blocks can be disabled individually, and this is explained in section \ref{sec:emu}.\cite{efm32-energy-optimization}

\subsubsection{Clock Optimization}
By adjusting the CPU clock in active mode (EM0), it is possible to reduce the static power consumption. Lets consider what happens when the CPU clock frequency is doubled. This will approximately double the dynamic power consumption, and at the same time it has the potential to halve the CPU processing time so that the CPU can enter a low energy mode sooner. As energy consumption is calculated as power consumption over time, the total energy consumed by dynamic power will be unaffected. However, halving the processing time will also halve the active mode static power consumption, thereby reducing the total static energy consumption. The conclusion is that computations in higher energy modes should be completed as fast as possible. The exception to this rule is when the CPU must wait for flash memory and flash wait-states are introduced.\cite{efm32-energy-optimization}

\subsubsection{Clock Gating}
Clock gating is a technique that reduces dynamic power consumption by disconnecting the clock from unused circuits. The EFM32GG supports manual clock gating of both core modules and peripherals on an individual basis (see section \ref{subsec:cmu}).\cite{efm32-energy-optimization} 

\subsubsection{Energy Modes}
TODO % TODO: Write about energy modes

\subsubsection{Reducing Bias Current of Analog Peripherals}
Most analog peripherals in the EFM32GG use something called a \emph{bias current}. It is possible to reduce this bias current to reduce power consumption, but this will affect the analog performance.\cite{efm32-energy-optimization}
% TODO (maybe): Expand this section by explaining what a bias current is

% A list of additional stuff that can be put into this section, mainly from
% application note AN0027 on energy optimization:
%
% Static power:
% - GPIO Leakage and schmitt triggering
% - Analog Bias Setting



\section{Generating Sounds}
When interpreting a sound as a signal, we speak about properties of the sound such as frequency, period, and amplitude. Here frequency and period (the inverse frequency) describes the pitch of a sound, while amplitude describes the loudness. In a typical speaker, a voltage signal is converted directly into sound waves. Here the voltage signal is an accurate model of the sound wave and has the same frequency and amplitude. The range of sounds that can be perceived by a human being is from 20Hz to 20KHz.\cite{compendium}

In order to generate 

According to the standard ISO 16, the frequency 

% TODO: Write about how we generate the different tones

\subsection{Music theory}

\subsubsection{Diatonic Scale}
In music theory, a diatonic scale is one composed of seven different pitch classes.
