\chapter{Results}
TODO
% In this chapter, you should discuss the results you have obtained from your
% implementation. These can be correctness results, i.e whether the
% implementation behaved as expected, or numerical results that express runtime
% or energy measurements.

\section{Energy Modes}
\label{sec:energyModeResults}
While a song is playing the board consumes a significant amount of power. To decrease the consupmtion, we tried different energy modes between interrupts. We measured energy consumption in EM0, EM1 and EM2. The results can be seen in table \ref{tab:benchmarkEnergyModes}. In our case EM1 gave best results and not EM2 as first expected.

\begin{table}[ht]
	\begin{center}
	\begin{tabular}{ |c|c|c| }
	  \hline
	  EM0 & EM1 & EM2 \\
	  \hline
	  4.85 mA & 4.02 mA & 4.51 mA \\
	  \hline

	\end{tabular}
	\caption{Energy consumption with different energy modes}
	\label{tab:benchmarkEnergyModes}
	\end{center}
\end{table}

\section{Song Size}
In order to compare the two implementations we needed to not only compare efficiency but also utility. 

\subsection{Synth Songs}
The synth based approach yielded fairly small song sizes, the tetris theme totalled at 204 bytes, needing only two arrays of respectively 38 and 64 16 bit integers. With this size we could fit in a lot of music before size would become an issue.

\subsection{Samples}
For the sample based apprach we used samples averaging at around 1640 integers per array for 0.05 seconds. Clearly the samples were a lot more memory intensive. While sample size could be brought down by only sampling a single waveform we decided 0.05 second samples would be more interesting to work with since they would allow for variance in the waveforms, creating more interesting tones. The final size per sample ended up averaging around 3280 bytes, a significant cost compared to the synth approach. However, reuse of samples can offset this cost somewhat since playing a note twice comes at the same cost as the synth approach
