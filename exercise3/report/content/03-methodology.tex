\chapter{Methodology}
% This chapter should discuss the details of your implementation for the
% assignment. Everything related to \emph{how} things were done should go here.
% Remember to avoid going into too much details, summarize appropriately and
% try to use figures/charts. Make sure you refer to the figures (such as Figure
% \ref{fig:universe}) and charts you add in the text. Avoid putting lots of
% source code here -- small code snippets are fine if you want to discuss
% something specific.

\section{Development Computer Setup}
This section briefly describes technical details regarding the system setup we used on our development computers.

\subsection{PTXdist}
The build process of this exercise was quite involved, and it was necessary to use the PTXdist build management tool, described in section \ref{sec:ptxdist}. In order to install PTXdist on our computers, two main options were provided along with the exercise:
\begin{itemize}
  \item A virtual machine with PTXdist and cross toolchain installed.
  \item A README file with instructions on how to build and install PTXdist and cross toolchain from sources.
\end{itemize}

Initially we used a computer with limited processing resources for development, and building PTXdist from sources was therefore the favoured alternative. By following the instructions, PTXdist and cross toolchain was installed successfully in a couple of hours.

A possible third option was to use the lab computers with PTXdist and cross toolchain already installed. This option was regarded as a fall-back solution in case of technical difficulties.

\subsection{Serial Terminal Emulator}
In order to access the running operating system, we connected a laptop running a serial terminal emulator to the serial port of the EFM32GG. The program used for terminal emulation was \emph{minicom}, an open source communication program available for most Unix and Unix-like operating systems.\cite{minicom-man-page} The compendium instructions was followed to set up parameters for the serial port:
\begin{itemize}
  \item Baud rate: 115200 bps
  \item Data bits: 8
  \item 1 stop bit
  \item No parity
  \item No flow control
\end{itemize}

\subsection{Git Version Control}
The Git version control tool was used to manage different code revisions. The free hosting service GitHub was used to host a Git repository at \url{https://github.com/jonatanl/TDT4258}. The branch ``master'' was used for code development.


\section{Part 1: Linux Build and Warm-Up}
When solving the exercise, we started out by doing the preliminary warm-up steps recommended by the compendium: building the uClinux operating system, and creating a simple application that used the framebuffer device \texttt{/dev/fb0}. The purpose of these steps was to familiarize with the development workflow and driver interfacing in Linux.

\subsection{Building uClinux}
Building uClinux was done without any problems by executing the commands \texttt{ptxdist images} and \texttt{ptxdist test flash-all}. A large amount of sources were downloaded and compiled, and the whole build process took about fifteen minutes. After the board was restarted, Tux appeared on the display showing that uClinux was running.

After having successfully configured the serial terminal emulator \emph{minicom}, we could communicate with the operating system via the serial port, and execute shell commands:
\lstset{style=lststyle-terminal}
\begin{lstlisting}
OSELAS(R)-Gecko-2012.10.0+ / energymicro-efm32gg-dk3750-2012.10.0+
ptxdist-2013.07.1/2015-03-16T15:23:07+0100

/ # game
Hello World, I'm game!
\end{lstlisting}

In order to further test the build chain, we made a small modification to the source file \texttt{game.c}, changing the \texttt{printf()} function arguments. After rerunning the necessary ptxdist actions, we observed the expected changes in the output of the \texttt{game} command:
\lstset{style=lststyle-terminal}
\begin{lstlisting}
/ # game
Hello World, I'm also a game!
\end{lstlisting}

\subsection{Creating a framebuffer application}
Our next step was to write a simple application accessing the framebuffer device. To write data to the framebuffer, we used the Linux system calls \texttt{open()}, \texttt{write()}, and \texttt{close()} described in section \ref{sec:reading-and-writing-files}.
TODO % TODO

\subsubsection{Accessing the driver as a file}
TODO % TODO

\subsubsection{Accessing the driver with a memory map}
TODO % TODO



\section{Testing}
% Add content in this section that describes how you tested and verified the
% correctness of your implementation, with respect to the requirements of the
% assignment.
