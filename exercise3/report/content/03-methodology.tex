\chapter{Methodology}
% This chapter should discuss the details of your implementation for the
% assignment. Everything related to \emph{how} things were done should go here.
% Remember to avoid going into too much details, summarize appropriately and
% try to use figures/charts. Make sure you refer to the figures (such as Figure
% \ref{fig:universe}) and charts you add in the text. Avoid putting lots of
% source code here -- small code snippets are fine if you want to discuss
% something specific.
This chapter explains the complete process that lead to our final product, and the details of the implementation. It begins by explaining the development setup we used, and then goes through the major steps of the process. The exercise compendium recommended to complete the exercise sequentially in three parts:
\begin{enumerate}
  \item Part 1: Linux Build and Warm-Up
  \item Part 2: The Driver
  \item Part 3: The Game
\end{enumerate}
We followed this approach closely, and an individual section is dedicated to each part.


\section{Development Setup}
This section briefly describes technical details regarding the system setup we used on our development computers.

\subsection{PTXdist}
The build process of this exercise was quite involved, and for this reason it was necessary to use the PTXdist build management tool, described in section \ref{sec:ptxdist}. In order to install PTXdist on our computers, two options were provided along with the exercise:
\begin{itemize}
  \item A virtual machine with PTXdist and cross toolchain installed.
  \item A README file with instructions on how to build and install PTXdist and cross toolchain from sources.
\end{itemize}
Initially we used a computer with limited processing resources for development, and building PTXdist from sources was therefore the favoured alternative. By following the instructions, PTXdist and cross toolchain was installed successfully in a couple of hours.

A possible third option was to use the lab computers with PTXdist and cross toolchain already installed. This option was regarded as a fall-back solution in case of technical difficulties.

\subsection{Serial Terminal Emulator}\label{sec:serial-terminal-emulator}
In order to access the running operating system, we connected a laptop running a serial terminal emulator to the serial port of the EFM32GG. The program used for terminal emulation was \emph{minicom}, an open source communication program available for most Unix and Unix-like operating systems.\cite{minicom-man-page} The compendium instructions was followed to set the following parameters for the serial port:
\begin{itemize}
  \item Baud rate: 115200 bps
  \item Data bits: 8
  \item 1 stop bit
  \item No parity
  \item No flow control
\end{itemize}

\subsection{Git Version Control}
To manage different code revisions, we used the Git version control system. The free hosting service GitHub was used to host a Git repository at \url{https://github.com/jonatanl/TDT4258}, and the branch ``master'' was used for code development.


\section{Part 1: Linux Build and Warm-Up}
When solving the exercise, we started out by doing preliminary warm-up steps recommended by the compendium: building the uClinux operating system, and creating a simple application that used the framebuffer device \texttt{/dev/fb0}. The purpose of these steps was to familiarize with the development workflow and driver interfacing in Linux.

\subsection{Building uClinux}
We used PTXdist to build uClinux by executing the commands \texttt{ptxdist images} and \texttt{ptxdist test flash-all} in the top-level project directory. A large amount of sources were downloaded and compiled, and the whole process took about fifteen minutes. PTXdist and its build process is described in section \ref{sec:ptxdist}. After the board was restarted, Tux appeared on the display showing that uClinux was running.

In order to communicate with the operating system, we configured the serial terminal emulator \emph{minicom} as described in section \ref{sec:serial-terminal-emulator}. This gave us access to a shell where we could execute commands. The output of executing the unmodified game application is shown in listing \ref{lst:initial-shell-commands1}.
\lstset{style=lststyle-terminal}
\begin{lstlisting}[caption=Executing the unmodified game,label=lst:initial-shell-commands1]
OSELAS(R)-Gecko-2012.10.0+ / energymicro-efm32gg-dk3750-2012.10.0+
ptxdist-2013.07.1/2015-03-16T15:23:07+0100

/ # game
Hello World, I'm game!
\end{lstlisting}

To test that we were also able to make changes to the code, we made a small modification to the game application by changing the \texttt{printf()} function arguments in \texttt{game.c}. After rerunning the necessary ptxdist actions, we observed the expected changes in the output of the \texttt{game} command:
\lstset{style=lststyle-terminal}
\begin{lstlisting}[caption=Executing a slightly modified game,label=lst:initial-shell-commands2]
/ # game
Hello World, I'm also game!
\end{lstlisting}
Notably, in order for \texttt{ptxdist compile game} to actually compile the modified sources of the game, we first had to run one of the commands \texttt{ptxdist clean game} and \texttt{ptxdist drop game compile}.

\subsection{Creating a framebuffer application}
Our next step was to write a simple application accessing the framebuffer device. To write data to the framebuffer, we used the Linux system calls \texttt{open()}, \texttt{write()}, and \texttt{close()} described in section \ref{sec:reading-and-writing-files}.

\todo{Uncompleted}

\subsubsection{Accessing the driver as a file}
\todo{Uncompleted}

\subsubsection{Accessing the driver with a memory map}
\todo{Uncompleted}


\section{Part 2: The Driver}
Having completed the first part of the exercise, it was time to write the gamepad driver. This section relies on the theory introduced in section \ref{writing-device-drivers-for-linux}.

\subsection{Registering a Character Device}
Following the procedure described in the compendium and in \cite{linux-device-drivers}, we wrote a simple driver that requested dynamically allocated device numbers and registered a character device in the kernel on initialization. On exit, the driver would remove the character device from the kernel and then deallocate the device numbers.

To pick up any errors, we checked all relevant error codes, using \texttt{printk()} to print out all nonzero codes. To verify our implementation, we checked the devices in \texttt{/proc/devices} before and after using \texttt{modprobe} and \texttt{rmmod}: the driver would appear with major device number 253 after calling \texttt{modprobe}, and disappear again after calling \texttt{rmmod}.

\subsection{Accessing the Driver}
The next step was to access the driver through the functions in the \texttt{file\_operations} structure. We added a \texttt{printk()} to each of the functions \texttt{open()} and \texttt{close()}, and we rewrote the game application so that it would try to open and close the file \texttt{/dev/gamepad0}. After having rebooted the operating system, started the new driver, and created a driver device file with the command \texttt{mknod /dev/gamepad0 c 253 0}. Then we executed the game application, and we were indeed able to see that the driver functions were being called.

\todo{Add command output here (see comment below in the .tex document)}
% / # game
% Trying to open the gamepad at /dev/gamepad0 ...
% [   99.810000] my_open()
% Trying to close the gamepad ...
% [   99.820000] my_release()


\section{Testing}
% Add content in this section that describes how you tested and verified the
% correctness of your implementation, with respect to the requirements of the
% assignment.
