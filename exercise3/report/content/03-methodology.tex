\chapter{Methodology}
% This chapter should discuss the details of your implementation for the
% assignment. Everything related to \emph{how} things were done should go here.
% Remember to avoid going into too much details, summarize appropriately and
% try to use figures/charts. Make sure you refer to the figures (such as Figure
% \ref{fig:universe}) and charts you add in the text. Avoid putting lots of
% source code here -- small code snippets are fine if you want to discuss
% something specific.
This chapter explains the complete process that lead to our final product, and the details of the implementation. It begins by explaining the development setup we used, and then goes through the process step by step. The exercise compendium recommended to complete the exercise sequentially in three parts:
\begin{enumerate}
  \item Part 1: Linux Build and Warm-Up
  \item Part 2: The Driver
  \item Part 3: The Game
\end{enumerate}
We tried to follow this approach closely. This chapter dedicates an individual section to each part.


\section{Development Setup}
This section briefly describes technical details regarding the system setup we used on our development computers.

\subsection{PTXdist}
The build process of this exercise was quite involved, and for this reason it was necessary to use the PTXdist build management tool, described in section \ref{sec:ptxdist}. In order to install PTXdist on our computers, two options were provided along with the exercise:
\begin{itemize}
  \item A virtual machine with PTXdist and cross toolchain installed.
  \item A README file with instructions on how to build and install PTXdist and cross toolchain from sources.
\end{itemize}
Initially we used a computer with limited processing resources for development, and building PTXdist from sources was therefore the favoured alternative. By following the instructions, PTXdist and cross toolchain was installed successfully in a couple of hours.

A possible third option was to use the lab computers with PTXdist and cross toolchain already installed. This option was regarded as a fall-back solution in case of technical difficulties.

\subsection{Serial Terminal Emulator}\label{sec:serial-terminal-emulator}
In order to access the running operating system, we connected a laptop running a serial terminal emulator to the serial port of the EFM32GG. The program used for terminal emulation was \emph{minicom}, an open source communication program available for most Unix and Unix-like operating systems.\cite{minicom-man-page} According to the compendium, the serial port was configured with the following parameters:
\begin{itemize}
  \item Baud rate: 115200 bps
  \item Data bits: 8
  \item 1 stop bit
  \item No parity
  \item No flow control
\end{itemize}

\subsection{Git Version Control}
To manage different code revisions, we used the Git version control system. The free hosting service GitHub was used to host a Git repository at \url{https://github.com/jonatanl/TDT4258}. During exercise 3, code was developed on the branch ``master'', and the report was written on branch ``report3''.


\section{Part 1: Linux Build and Warm-Up}
When solving the exercise, we started out by doing the preliminary warm-up steps recommended by the compendium: building the uClinux operating system, and creating a simple application that used the framebuffer device \texttt{/dev/fb0}. The purpose of these steps was to familiarize with the development workflow and driver interfacing in Linux.

\subsection{Building uClinux}
We used PTXdist to build uClinux by executing the commands \texttt{ptxdist images} and \texttt{ptxdist test flash-all} in the top-level project directory. A large amount of sources were downloaded and compiled, and the whole process took about fifteen minutes. PTXdist and its build process is described in section \ref{sec:ptxdist}. After the board was restarted, Tux appeared on the display showing that uClinux was running.

\subsection{Communicating with uClinux}
In order to communicate with the operating system, we configured the serial terminal emulator \emph{minicom} as described in section \ref{sec:serial-terminal-emulator}. This gave us access to a shell where we could execute commands. The output of executing the unmodified game application is shown in listing \ref{lst:initial-shell-commands1}.
\lstset{style=lststyle-terminal}
\begin{lstlisting}[caption=The original game application,label=lst:initial-shell-commands1]
OSELAS(R)-Gecko-2012.10.0+ / energymicro-efm32gg-dk3750-2012.10.0+
ptxdist-2013.07.1/2015-03-16T15:23:07+0100

/ # game
Hello World, I'm game!
\end{lstlisting}

To further verify that our code was actually compiling, we made a small modification to the game application by changing the \texttt{printf()} function arguments in \texttt{game.c}. After rerunning the necessary ptxdist actions, the output of the \texttt{game} command had indeed changed:
\lstset{style=lststyle-terminal}
\begin{lstlisting}[caption=A modified game application,label=lst:initial-shell-commands2]
/ # game
Hello World, I'm also game!
\end{lstlisting}
Notably, in order for \texttt{ptxdist compile game} to actually compile the modified sources of the game, we first had to run the command \texttt{ptxdist clean game}.

\subsection{Creating a framebuffer application}
Our next step was to write a simple application accessing the framebuffer device described in section \ref{sec:the-framebuffer}.

\subsubsection{Accessing the framebuffer as a file}
Initially we used the Linux system calls \texttt{open()}, \texttt{write()}, and \texttt{close()} described in section \ref{sec:reading-and-writing-files} to write data to the framebuffer. The application would fill an array with \texttt{uint16\_t} values corresponding to yellow pixels, and then write those values to the framebuffer. The array was large enough that half the screen was drawn yellow, making Tux disappear. A small artifact was observed at the left edge of the screen area. An image of the screen is shown in figure \ref{fig:TODO}.

\todo{Add picture of screen artifact}

\subsubsection{Accessing the framebuffer with a memory map}
The compendium recommended to access the framebuffer through a memory mapping. This was achieved with the function \texttt{mmap()} described in section \ref{sec:mapping-files-to-memory}. Mapping the framebuffer to memory allowed us to access the framebuffer as an array of pixels. To demonstrate the increased freedom, the application colored every other pixel yellow, partly obscuring Tux behind a yellow haze.


\section{Part 2: The Driver}
Having completed the first part of the exercise, it was time to write the gamepad driver. Before continuing, the reader might consider reviewing section \ref{writing-device-drivers-for-linux}, as it introduces theory fundamental to this section.

\subsection{Registering a Character Device}
Following steps described in the compendium and in \cite{linux-device-drivers}, we wrote a simple driver that requested dynamically allocated device numbers and registered a character device in the kernel on initialization. On exit, the driver would remove the character device from the kernel and then deallocate the device numbers.

To pick up any errors, we checked for relevant errors by using \texttt{printk()} to print out any nonzero error codes. To verify our implementation, we checked the devices in \texttt{/proc/devices} before and after using \texttt{modprobe} and \texttt{rmmod}: the driver would appear with major device number 253 after running \texttt{modprobe}, and disappear again after calling \texttt{rmmod}.

\subsection{Accessing the Driver}
The next step was to access the driver through the functions in the \texttt{file\_operations} structure. We added a \texttt{printk()} statement to each of the functions \texttt{open()} and \texttt{close()} that would output the name of the function, and rewrote the game application so that it would try to open and close the file \texttt{/dev/gamepad0}. Then we rebooted the operating system, loaded the new driver and created a driver device file manually with the command \texttt{mknod /dev/gamepad0 c 253 0}. unning the game application produced the expected output:
\lstset{style=lststyle-terminal}
\begin{lstlisting}[caption=Accessing the driver,label=lst:accessing-the-driver]
/ # game
Trying to open the gamepad at /dev/gamepad0 ...
[   99.810000] my_open()
Trying to close the gamepad ...
[   99.820000] my_release()
\end{lstlisting}

\subsection{Creating the Device File Automatically}
So that we would not have to create the device file manually with \texttt{mknod} each time testing the driver, we rewrote the driver so that it would create the device file ``driver-gamepad'' on initialization, as described in section \ref{sec:creating-device-files}.

\subsection{Reading the Gamepad Buttons}
In order to receive input from the gamepad buttons, we needed to access the GPIO port to which the gamepad was connected. For a description of the GPIO hardware on the EFM32GG, see section \ref{sec:gpio}. However, we could not access the hardware directly: the Linux operating system manages hardware access through so-called I/O ports. Drivers that want to access hardware must acquire access to that hardware through special kernel calls. A description of I/O ports and hardware access in Linux is found in section \ref{sec:accessing-hardware-registers}.

In our implementation, the function \texttt{setup\_gpio()} would be called during driver initialization. This function would request access to the GPIO registers, map them to memory, and set up the GPIO pins on port C for input. A similar function \texttt{teardown\_gpio} would release the resources on driver exit. On a read, the driver would simply copy the value of \texttt{GPIO\_PC\_DIN} to the user buffer.

To verify our implementation, we rewrote the game application so that it would sit in a tight loop, reading the device and printing new results received to output. The output is shown in listing \ref{lst:reading-the-gamepad-buttons}.
\begin{lstlisting}[caption=Reading the gamepad buttons,label=lst:reading-the-gamepad-buttons]
/ # game
Trying to open the gamepad at /dev/driver-gamepad ...
[   12.960000] gamepad_open()
Waiting for button input ... (Press Button 8 to exit)
GPIO_PC_DIN: 1
GPIO_PC_DIN: 0
GPIO_PC_DIN: 64
GPIO_PC_DIN: 0
GPIO_PC_DIN: 128
Trying to close the gamepad ...
[   20.360000] gamepad_release()
\end{lstlisting}

\subsection{Implementing the Seek Operation}
At this point, we implemented the \texttt{llseek} file operation. The \texttt{llseek} file operation is the back-end implementation of the \texttt{lseek} system call, described in section \ref{sec:reading-and-writing-files}. The \texttt{read} operation was also rewritten to update the file offset on read and return \texttt{EOF} on any offset beyond the start of the file. To read the new device without having to call \texttt{lseek} manually each time, the \texttt{pread()} system way used. 

At this point the utility of \texttt{llseek} was not very much. However, it was reasoned that this was a good way to provide access multiple registers.



\section{Testing}
% Add content in this section that describes how you tested and verified the
% correctness of your implementation, with respect to the requirements of the
% assignment.
