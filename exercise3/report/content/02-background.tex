\chapter{Background and Theory}
% This chapter should describe the theoretical background needed to understand
% and solve the problem. For instance, a description of the hardware platform
% or specific components involved in this assignment, definition of concepts
% that are important to understand the solution should be summarized here. Add
% citations to show sources whenever appropriate, LaTeX and bibliography
% managers make this easy.

% TODO: Write an introduction to ptxdist usage


\section{Operating Systems}
An operating system is a special piece of software that provides two important functions in a computer:
\begin{itemize}
  \item Managing the hardware resources.
  \item Providing a useful hardware abstraction layer for application programmers.
\end{itemize}
The core of the operating system is called the \emph{kernel} and runs in a privileged software mode that gives the kernel complete access to all hardware resources. The code running outside the kernel is often referred to as the \emph{user space} or the \emph{userland}, and has only restricted access to hardware. Because of this organization, all hardware-related activities necessary to run the operating system is performed by the kernel, and the user space programs only access hardware through \emph{system calls} in the kernel.\cite{modern-operating-systems}

\subsection{Device Drivers}
To more easily manage hardware devices with different characteristics, the kernel contains \emph{device drivers}. A device driver is a program that manages low-level hardware access to a particular device, providing a clean interface for the rest of the kernel programs.

\subsection{Kernel Modules}
It is sometimes necessary to extend the functionality of the kernel, for instance if new hardware becomes available. While this could be achieved by modifying and rebuilding the kernel, a much more attractive alternative is to use \emph{kernel modules}, small programs that are loaded at runtime and extend the kernel with the needed functionality. Device drivers can be added as kernel modules.

\subsection{Related Terminology}
In addition to the concepts described above, several other terms are used in the context of operating systems:
\begin{itemize}
\item \textsl{Boot Loader:} The bootloader is a small program that runs before the operating system starts, and makes the necessary preparations to start the kernel.
\item \textsl{Linux Root Filesystem:} In Linux, the root filesystem is the filesystem available at the top-level directory. It is denoted with a forward slash, "/".
\end{itemize}


\section{Linux}
TODO % TODO: Needs intro

\subsection{System calls}
TODO % TODO: Needs intro

\subsubsection{Reading and writing files}\label{sec:reading-and-writing-files}
Several system calls in Linux are related to file operations such as reading and writing. This section will introduce \texttt{open()}, \texttt{read()}, \texttt{write()}, \texttt{lseek()} and \texttt{close()}.

Before any file operations can be performed on a file, system resources needs to be allocated for the file, for instance with a call to \texttt{open()}:
\begin{verbatim}
  int open(const char *pathname, int flags);
\end{verbatim}
Here \texttt{pathname} is the absolute path to the file, and \texttt{flags} specify access modes such as read-only or read-write. On success, \texttt{open()} will return a file descriptor that is used as a handle when modifying the file with future system calls.

After opening a file with \texttt{open()}, the contents of the file can be read as individual bytes with \texttt{read()}:
\begin{verbatim}
  ssize_t read(int fd, void *buf, size_t count);
\end{verbatim}
Here \texttt{fd} is the file descriptor previously returned from \texttt{open()}, \texttt{buf} is a buffer where the file contents should be stored, and \texttt{count} is the number of bytes to read from the file. The returned value is the number of bytes that was read into \texttt{buf}. Note that \texttt{read()} gives no guarantee that the requested number of bytes has actually been read into \texttt{buf}. It is up to the application programmer to provide such guarantees by checking the return value.

In order to write write bytes to a file, it is possible to use the very similar function \texttt{write()}:
\begin{verbatim}
  ssize_t write(int fd, const void *buf, size_t count);
\end{verbatim}
Here the roles of the parameters are reversed: \texttt{buf} is a buffer containing the contents to write to the file, \texttt{count} specifies the number of bytes to write, and the value returned is the actual number of bytes written. As expected, \texttt{fd} is the file descriptor.

The functions \texttt{read()} and \texttt{write()} both perform their operations on the bytes located at a specific offset from the beginning of the file, called the \emph{file offset}. The file offset starts at the beginning of the file, and is incremented whenever a number of bytes is read or written by a file operation. To operate on bytes in a noncontiguous fashion, the offset needs to be changed with a call to \texttt{lseek()}:
\begin{verbatim}
  off_t lseek(int fd, off_t offset, int whence);
\end{verbatim}
Here the meaning of \texttt{offset} depends on the parameter \texttt{whence}. Three possible options are to specify the new offset directly, relative to the current offset, or relative to the end of the file.

After an application is done with a file, the resources associated with that file can be released by calling \texttt{close()}:
\begin{verbatim}
  int close(int fd);
\end{verbatim}
This will invalidate the file descriptor.


\subsubsection{Mapping files to memory}
TODO % TODO



\section{PTXdist}\label{sec:ptxdist}
PTXdist is a build system used to develop userland software for embedded platforms running Linux. It can control most parts of the build process:
\begin{itemize}
  \item Download package sources
  \item Extract package sources and apply patches
  \item Configure packages
  \item Build packages
  \item Create filesystem images
  \item Flash filesystem images to target
\end{itemize}
PTXdist builds the Linux kernel used along with the userland software.

\subsection{Project Setup}
Setting up a PXTdist project consists of the following steps:
\begin{itemize}
  \item Selecting a userland configuration.
  \item Selecting a hardware platform.
  \item Selecting a toolchain.
\end{itemize}
The userland configuration defines what user programs will be built for the target platform apart from the kernel, and the hardware platform defines the target platform of the build. The toolchain selected is the toolchain PTXdist should use when building. As PTXdist looks for toolchains in the /opt folder, selecting a toolchain is not always necessary.

\subsection{Building and Flashing}
After the project has been setup, the kernel and the user programs can be built with one simple command:
\lstset{style=lststyle-terminal}
\begin{lstlisting}
ptxdist go
\end{lstlisting}
This will build several filesystem images for the target platform containing the kernel and all userland programs specified by the userland configuration. PTXdist will automatically find out which packages needs to be built, and download them if necessary.

Finally, the images can then be flashed onto the target platform with the command:
\lstset{style=lststyle-terminal}
\begin{lstlisting}
ptxdist images
\end{lstlisting}
An illustration of how the PTXdist build process might be for a computer game is shown in figure \ref{fig:ptxdist-build-process}.

\begin{figure}[ht]\label{fig:ptxdist-build-process}
  \includegraphics[width=\textwidth]{images/ptxdist_build_process.png}
  \caption{An example overview of a PTXdist build process for a computer game.}
\end{figure}

