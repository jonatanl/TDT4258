\chapter{Background and Theory}
% This chapter should describe the theoretical background needed to understand
% and solve the problem. For instance, a description of the hardware platform
% or specific components involved in this assignment, definition of concepts
% that are important to understand the solution should be summarized here. Add
% citations to show sources whenever appropriate, LaTeX and bibliography
% managers make this easy.

This chapter is an introduction to theory and concepts needed to understand the rest of the report. It begins with a section explaining operating systems terminology and a section introducing the Linux operating systems and important system calls. Then it continues in the next section with a study of driver programming in Linux, and ends with an introduction of the PTXdist build system.

\todo{Verify that this is consistent with the rest of the chapter}

\section{Basic Terminology}
This section introduces some general terminology and concepts concerning operating systems and device drivers in general.

\subsection{Operating Systems}
An operating system is a special piece of software that provides two important functions in a computer:
\begin{itemize}
  \item Managing the hardware resources.
  \item Providing a useful hardware abstraction layer for application programmers.
\end{itemize}
The core of the operating system is called the \emph{kernel} and runs in a privileged software that gives the kernel complete access to all hardware resources. The code running outside the kernel is often referred to as the \emph{user space} or the \emph{userland}, and has only restricted access to hardware. Because of this organization, all hardware-related activities necessary to run the operating system and execute programs is performed by the kernel, and the user space programs only access hardware through the kernel by special \emph{system calls}.
\cite{modern-operating-systems}

\subsection{Device Drivers}
The kernel uses \emph{device drivers} to more easily manage hardware devices with different characteristics. A device driver is a program that manages low-level access to a particular hardware device, providing a clean interface for the rest of the kernel.

\subsection{Kernel Modules}\label{sec:kernel-modules}
The functionality of the kernel may sometimes need to be modified, for instance to accommodate new hardware. While this could be achieved by modifying and rebuilding the kernel, it is often a more attractive alternative to extend the functionality with \emph{kernel modules}, small kernel programs that are loaded at runtime. It is common to write device drivers as kernel modules.

\subsection{Related Terminology}
In addition to the concepts described above, several other terms are used in the context of operating systems:
\begin{description}
\item[Boot Loader] \hfill \\
The bootloader is a small program that runs before the operating system starts, and makes the necessary preparations to load the kernel.
\item[Linux Root Filesystem] \hfill \\
 In Linux, the root filesystem is the filesystem available at the top-level directory. It is denoted with a forward slash, \texttt{/}.
\end{description}

\todo{Things to consider writing about here: \\
\indent - The virtual address space of processes}


\section{Linux}
\todo{Needs an introduction}

\subsection{System calls}
\todo{Needs an introduction}

\subsubsection{Reading and writing files}\label{sec:reading-and-writing-files}
Several system calls in Linux are related to file operations that perform file I/O. This section will introduce some of the most commonly used. The following system calls are available from the headers \texttt{<fcntl.h>} and \texttt{<unistd.h>}.

\begin{description}
\item[\texttt{int open(const char *pathname, int flags);}] \hfill \\
Before any file operations can be performed on a file, a call to \texttt{open()} is needed to allocate the necessary system resources. Here \texttt{pathname} is the absolute path to the file, and \texttt{flags} specify access modes such as read-only or read-write. On success, \texttt{open()} will return a file descriptor that is used as a handle on the file in future system calls.
\item[\texttt{ssize\_t read(int fd, void *buf, size\_t count);}] \hfill \\
After opening a file, the contents of the file can be read as individual bytes with \texttt{read()}. Here \texttt{fd} is the file descriptor previously returned from \texttt{open()}, \texttt{buf} is a buffer where the file contents should be stored, and \texttt{count} is the number of bytes to read from the file. The returned value is the number of bytes that was read into \texttt{buf}. Note that \texttt{read()} gives no guarantee that the requested number of bytes has actually been read into \texttt{buf}. It is up to the application programmer to provide such guarantees by checking the return value.
\item[\texttt{ssize\_t write(int fd, const void *buf, size\_t count);}] \hfill \\
To write bytes to a file, the very similar function \texttt{write()} can be used. The parameters roles are slightly changed: \texttt{buf} is a buffer containing the contents to write to the file, \texttt{count} specifies the number of bytes to write, and the value returned is the actual number of bytes written. As expected, \texttt{fd} is the file descriptor.
\item[\texttt{off\_t lseek(int fd, off\_t offset, int whence);}] \hfill \\
Read and write operations on a file is performed at the bytes located at a specific offset from the beginning of the file, called the \emph{file offset}. The file offset is initially zero, and is incremented with the number of bytes read or written by a file operation. To operate on bytes in a noncontiguous fashion, the offset can be changed with a call to \texttt{lseek()}. Here the meaning of \texttt{offset} depends on the parameter \texttt{whence}. Three possible options are to specify the new offset directly, relative to the current offset, or relative to the end of the file.
\item[\texttt{int close(int fd);}] \hfill \\
After an application is done with a file it should call \texttt{close()} to release the file's associated resources. This will invalidate the file descriptor.
\end{description}

\subsubsection{Mapping files to memory}\label{mapping-files-to-memory}
Accessing a file in an arbitrary manner using the system calls described in section \ref{sec:reading-and-writing-files} will involve many redundant calls to \texttt{lseek()}. A better alternative then is to map the file into the virtual address space of the process, allowing the file to be accessed with ordinary memory accesses. The following system calls are available from the headers \texttt{<sys/mman.h>} and \texttt{<unistd.h>}.

\begin{description}
\item[\texttt{void *mmap(void *addr, size\_t length, int prot, int flags, int fd, off\_t offset);}]
The function \texttt{mmap()} can be used to map a number of \texttt{length} bytes from the file specified by the file descriptor \texttt{fd} into memory. The mapping starts \texttt{offset} bytes from the beginning of the file. Optionally, \texttt{addr} can be used to give the kernel a hint as to where the mapping should be placed in virtual memory, or it can be \texttt{NULL}. \texttt{prot} is a bit field specifying the memory protection of the mapping, and \texttt{flags} sets the visibility of updates to the mapping to other processes.
\item[\texttt{int msync(void *addr, size\_t length, int flags);}] \hfill \\
Updates to a memory mapped file might not become visible immediately. To synchronize a file with a memory map, the application should call \texttt{msync()}.
\item[\texttt{int munmap(void *addr, size\_t length);}] \hfill \\
After the application is done with the memory map, it may call \texttt{unmap()} to delete the mapping and release its associated resources. This will also synchronize the file with the memory map.
\end{description}



\section{Writing Device Drivers for Linux}\label{writing-device-drivers-for-linux}
This section is a brief introduction to device driver development for the Linux kernel. It begins by explaining some practical details regarding driver development, then it highlights some important parts of the Linux kernel and common programming constructs, and finally it provides a brief outline on driver design. The main focus is on drivers implemented as kernel modules. For an explanation on the terminology used in this section, see section \ref{TODO}.

\todo{Verify that this is consistent with the rest of the chapter}


\subsection{Programming in the Kernel}
Kernel modules are different from user space applications in several important ways, and there are some considerations to take into account when writing a module.

As a module is a part of the kernel, it runs in privileged mode with access to all hardware. A natural consequence of this is that bugs are much more serious. A module bug can easily crash the whole system, for instance by overwriting other parts of the kernel code in memory.

Again, because a module runs in privileged mode, it cannot be linked against any user space code. This includes the standard C library with all its nice functions such as \texttt{malloc()}, \texttt{strcmp()} and \texttt{printf()}. Instead, the module is linked against the kernel and has access to kernel routines.

Debugging is also different: the Linux kernel cannot be debugged with any user space debugger such as the GNU Debugger. Instead, the built-in kernel debugger must be used.

It is also worth mentioning that modules are linked against the kernel, meaning that the developer must have a kernel source tree available to build it against. The process of manually downloading, configuring and building a kernel source tree involves a fair amount of work, especially for a novice module programmer.


\subsection{Loading and Unloading Modules}
As explained in section \ref{sec:kernel-modules}, the kernel functionality can be extended by modules loaded at runtime. The following commands can be used to load and unload modules:
\begin{itemize}
  \item \texttt{insmod <module>} will load a module into memory and initialize it.
  \item \texttt{modprobe <module>} will load and initialize a module along with all its dependencies.
  \item \texttt{rmmod <module>} will perform cleanup and unload a module.
\end{itemize}
The modules are in control of their own initialization and cleanup processes. This is achieved by having each module define special initialization and exit functions that will be called whenever the module is loaded and unloaded respectively, as explained in the next section.


\subsection{A Simple Example}
The following example program illustrates the basic structure of driver module:
\lstset{style=lststyle-c}
\begin{lstlisting}
#include<linux/init.h>
#include<linux/module.h>

static int hello_init(void)
{
  printk(KERN_ALERT "Hello, world.\n");
}

static void hello_exit(void)
{
  printk(KERN_ALERT "Bye bye world, nice meeting you.\n");
}

module_init(hello_init);
module_exit(hello_exit);
\end{lstlisting}
This simple module uses the kernel function \texttt{printk()} to print messages when it is loaded and unloaded. Initialization and cleanup is done through the functions \texttt{hello\_init()} and \texttt{hello\_exit()} respectively. The important thing to note here is the functions \texttt{module\_init()} and \texttt{module\_exit()} at the last two lines: these are special macros that indicates to the kernel which functions to use for initialization and cleanup.

The included header files are included by almost all modules. Note that they are not system headers, but headers from the kernel source tree.


\subsection{Devices Files}
In Unix-like operating systems, user space applications access drivers through so-called \emph{device files} or \emph{special files}. These are similar to ordinary files in that they support many standard system calls for files, including the file operations described in section \ref{sec:reading-and-writing-files}. Notably, this is often true even for those drivers that do not provide access to storage devices at all. In any case, a driver provides its interface to the user space applications by implementing the needed system calls, and the implementation of those system calls constitutes a core part of the driver.

A device file contains information to identify the driver that owns it, namely a \emph{major} and a \emph{minor revision number}.

\todo{Write about how drivers registers device nodes in /dev}
\todo{Write about how device nodes can be created with \texttt{mknod}}


\subsection{Implementing Driver Operations}
We just explained that drivers are accessed through file operations that they define on a device file. This naturally begs the question of how those file operations are actually defined. In order to understand this, we need to look into how operations on files work in general for ordinary and special files alike.

The kernel uses the structure \texttt{struct file} from the kernel header \texttt{<linux/fs.h>} to manage open files. Some important fields of this structure are listed here:
\begin{description}
  \item[\texttt{mode\_t f\_mode;}] \hfill \\
    \texttt{f\_mode} is a bit field that stores the access mode of the file in the two bits \texttt{FMODE\_READ} and \texttt{FMODE\_WRITE}.
  \item[\texttt{loff\_t f\_pos;}] \hfill \\
    \texttt{f\_pos} is a 64-bit integer storing the current offset into the file.
  \item[\texttt{struct dentry *f\_dentry;}] \hfill \\
    \texttt{f\_dentry} points to a structure storing the directory entry of the file.   
  \item[\texttt{struct file\_operations *f\_op;}] \hfill \\
    \texttt{f\_op} points to a structure containing file operations to be used with the file.
\end{description}
The reader might be familiar with several of these file attributes. What is important, though, is the file operation structure associated with a file, \texttt{f\_op}. It is this structure that a driver uses to define the file operations of the device file. Below is a description of some fields in the structure \texttt{struct file\_operations}:
\begin{description}
  \item[\texttt{int (*open) (struct inode *, struct file *);}] \hfill \\
    Pointer to a function that is called whenever \texttt{open()} is called on the file.
  \item[\texttt{ssize\_t (*read) (struct file *, char \_\_user *, size\_t, loff\_t *);}] \hfill \\
    Pointer to a function that is called whenever \texttt{read()} is called on the file.
  \item[\texttt{ssize\_t (*write) (struct file *, const char \_\_user *, size\_t, loff\_t *);}] \hfill \\
    Pointer to a function that is called whenever \texttt{write()} is called on the file.
  \item[\texttt{loff\_t (*llseek) (struct file *, loff\_t, int);}] \hfill \\
    Pointer to a function that is called whenever \texttt{lseek()} is called on the file.
\end{description}
This structure reveals that drivers implement file operations on special files by providing a function pointer for each operation. These function pointers will likely point to internal driver functions.

\todo{Write about how drivers register facilities and file operation structures}


\subsection{Handling Concurrency}
The driver is shared between the processes running on a system, and must correctly handle the scenario that two or more processes wants to use the driver at once. To share the driver between multiple processes, it might be necessary to manage resources on a per-process basis using data structures. In addition, the resources shared between the processes needs to be sufficiently protected with synchronization primitives to avoid race conditions.

As a driver registers its facilities, other parts of the kernel might try to use those facilities immediately. The driver needs to handle this case that some parts of the kernel try to use it before it is completely initialized.

\todo{Expand this section when we have some experience about concurrency handling.}


\subsection{Handling Errors}
When a driver registers a facility during initialization, there is no guarantee that the kernel is able grant the driver's request. The driver might still recover from such an event to provide either full or some partial service, but in the event that the driver is not able to continue, it should unregister all facilities previously registered successfully. This may require that the driver uses some sort of scheme to track which facilities was registered successfully and which failed. 

\todo{Write about "facilities" somewhere. Mentioned in the book LDD chapter two, I think}


\subsection{Mechanism versus Policy}
\todo{Write about "Mechanism vs Policy", as discussed by "Linux Device Driver" early in chapter 1}



\section{PTXdist}\label{sec:ptxdist}
PTXdist is a build system used to develop userland software for embedded platforms running Linux. It can control most parts of the build process:
\begin{itemize}
  \item Download package sources
  \item Extract package sources and apply patches
  \item Configure packages
  \item Build packages
  \item Create filesystem images
  \item Flash filesystem images to target
\end{itemize}
PTXdist builds the Linux kernel used along with the userland software.

\subsection{Project Setup}
Setting up a PXTdist project consists of the following steps:
\begin{itemize}
  \item Selecting a userland configuration.
  \item Selecting a hardware platform.
  \item Selecting a toolchain.
\end{itemize}
The userland configuration defines what user programs will be built for the target platform apart from the kernel, and the hardware platform defines the target platform of the build. The toolchain selected is the toolchain PTXdist should use when building. As PTXdist looks for toolchains in the /opt folder, selecting a toolchain is not always necessary.

\subsection{Building and Flashing}
After the project has been setup, the kernel and the user programs can be built with one simple command:
\lstset{style=lststyle-terminal}
\begin{lstlisting}
ptxdist go
\end{lstlisting}
This will build several filesystem images for the target platform containing the kernel and all userland programs specified by the userland configuration. PTXdist will automatically find out which packages needs to be built, and download them if necessary.

Finally, the images can then be flashed onto the target platform with the command:
\lstset{style=lststyle-terminal}
\begin{lstlisting}
ptxdist images
\end{lstlisting}
An illustration of how the PTXdist build process might be for a computer game is shown in figure \ref{fig:ptxdist-build-process}.

\begin{figure}[ht]\label{fig:ptxdist-build-process}
  \includegraphics[width=\textwidth]{images/ptxdist_build_process.png}
  \caption{An example overview of a PTXdist build process for a computer game.}
\end{figure}

