\chapter{Background and Theory}
% This chapter should describe the theoretical background needed to understand
% and solve the problem. For instance, a description of the hardware platform
% or specific components involved in this assignment, definition of concepts
% that are important to understand the solution should be summarized here. Add
% citations to show sources whenever appropriate, LaTeX and bibliography
% managers make this easy.

% TODO: Write an introduction to ptxdist usage


\section{Operating Systems}
An operating system is a special piece of software that provides two important functions in a computer:
\begin{itemize}
  \item Managing the hardware resources.
  \item Providing a useful hardware abstraction layer for application programmers.
\end{itemize}
The core of the operating system is called the \emph{kernel} and runs in a privileged software mode that gives the kernel complete access to all hardware resources. The code running outside the kernel is often referred to as the \emph{user space} or the \emph{userland}, and has only restricted access to hardware. Because of this organization, all hardware-related activities necessary to run the operating system is performed by the kernel, and the user space programs only access hardware through \emph{system calls} in the kernel.\cite{modern-operating-systems}

\subsection{Device Drivers}
To more easily manage hardware devices with different characteristics, the kernel contains \emph{device drivers}. A device driver is a program that manages low-level hardware access to a particular device, providing a clean interface for the rest of the kernel programs.

\subsection{Kernel Modules}
It is sometimes necessary to extend the functionality of the kernel, for instance if new hardware becomes available. While this could be achieved by modifying and rebuilding the kernel, a much more attractive alternative is to use \emph{kernel modules}, small programs that are loaded at runtime and extend the kernel with the needed functionality. Device drivers can be added as kernel modules.

\subsection{Related Terminology}
In addition to the concepts described above, several other terms are used in the context of operating systems:
\begin{itemize}
\item \textsl{Boot Loader:} The bootloader is a small program that runs before the operating system starts, and makes the necessary preparations to start the kernel.
\item \textsl{Linux Root Filesystem:} In Linux, the root filesystem is the filesystem available at the top-level directory. It is denoted with a forward slash, "/".
\end{itemize}
% TODO: Things to consider putting in here:
%   - Virtual address space (of a process)


\section{Linux}
TODO % TODO: Needs intro

\subsection{System calls}
TODO % TODO: Needs intro

\subsubsection{Reading and writing files}\label{sec:reading-and-writing-files}
Several system calls in Linux are related to file operations such as reading and writing. This section will introduce \texttt{open()}, \texttt{read()}, \texttt{write()}, \texttt{lseek()} and \texttt{close()}, available from the headers \texttt{fcntl.h} and \texttt{unistd.h}.

Before any file operations can be performed on a file, system resources needs to be allocated for the file, for instance with a call to \texttt{open()}:
\begin{verbatim}
  int open(const char *pathname, int flags);
\end{verbatim}
Here \texttt{pathname} is the absolute path to the file, and \texttt{flags} specify access modes such as read-only or read-write. On success, \texttt{open()} will return a file descriptor that is used as a handle when modifying the file with future system calls.

After opening a file with \texttt{open()}, the contents of the file can be read as individual bytes with \texttt{read()}:
\begin{verbatim}
  ssize_t read(int fd, void *buf, size_t count);
\end{verbatim}
Here \texttt{fd} is the file descriptor previously returned from \texttt{open()}, \texttt{buf} is a buffer where the file contents should be stored, and \texttt{count} is the number of bytes to read from the file. The returned value is the number of bytes that was read into \texttt{buf}. Note that \texttt{read()} gives no guarantee that the requested number of bytes has actually been read into \texttt{buf}. It is up to the application programmer to provide such guarantees by checking the return value.

In order to write write bytes to a file, it is possible to use the very similar function \texttt{write()}:
\begin{verbatim}
  ssize_t write(int fd, const void *buf, size_t count);
\end{verbatim}
Here the roles of the parameters are reversed: \texttt{buf} is a buffer containing the contents to write to the file, \texttt{count} specifies the number of bytes to write, and the value returned is the actual number of bytes written. As expected, \texttt{fd} is the file descriptor.

The functions \texttt{read()} and \texttt{write()} both perform their operations on the bytes located at a specific offset from the beginning of the file, called the \emph{file offset}. The file offset starts at the beginning of the file, and is incremented whenever a number of bytes is read or written by a file operation. To operate on bytes in a noncontiguous fashion, the offset needs to be changed with a call to \texttt{lseek()}:
\begin{verbatim}
  off_t lseek(int fd, off_t offset, int whence);
\end{verbatim}
Here the meaning of \texttt{offset} depends on the parameter \texttt{whence}. Three possible options are to specify the new offset directly, relative to the current offset, or relative to the end of the file.

After an application is done with a file, the resources associated with that file can be released by calling \texttt{close()}:
\begin{verbatim}
  int close(int fd);
\end{verbatim}
This will invalidate the file descriptor.\cite{linux-man-pages}


\subsubsection{Mapping files to memory}\label{mapping-files-to-memory}
Accessing a file in an arbitrary manner using the system calls described in \ref{sec:reading-and-writing-files} will involve many redundant calls to \texttt{lseek()}. A better alternative then is to map the file into the virtual address space of the process using \texttt{mmap()}, which will allow the file to be accessed with ordinary memory accesses:
\begin{verbatim}
  void *mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);
\end{verbatim}
This will map a number of \texttt{length} bytes from the file specified by the file descriptor \texttt{fd}, starting 
\texttt{offset} bytes from the beginning of the file. \texttt{addr} can be optionally used to give the kernel a hint as to where the mapping should be placed in virtual memory, or it can be \texttt{NULL}. \texttt{prot} is a bitfield specifying the memory protection of the mapping, and \texttt{flags} sets the visibility of updates to the mapping to other processes. An example of \texttt{mmap()} is shown in listing \ref{lst:mapping-file-to-memory}.
\lstset{style=lststyle-c}
\begin{lstlisting}[caption=Mapping the first 120 bytes of a file to memory,label=lst:mapping-file-to-memory]
void *map = mmap(NULL, 120, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
\end{lstlisting}

Updates to a memory mapped file might not become visible immediately. To synchronize a file with a memory map, the application should call \texttt{msync()}:
\begin{verbatim}
  int msync(void *addr, size_t length, int flags);
\end{verbatim}

After the application is done with the memory map, it may call \texttt{unmap()} to delete the mapping and release its associated resources: 
\begin{verbatim}
  int munmap(void *addr, size_t length);
\end{verbatim}
This will also cause the file to become synchronized with the memory map.



\section{Writing Device Drivers for Linux}
TODO % TODO

\subsection{Development Setup}
TODO % TODO

\subsection{Loading and Unloading Modules}
TODO % TODO

\subsection{Programming Basics}
TODO % TODO

\subsection{Debugging Drivers}
TODO % TODO

\subsection{Error Handling}
TODO % TODO

\subsection{Licensing}
TODO % TODO

\subsection{Mechanism versus Policy}
TODO % TODO



\section{PTXdist}\label{sec:ptxdist}
PTXdist is a build system used to develop userland software for embedded platforms running Linux. It can control most parts of the build process:
\begin{itemize}
  \item Download package sources
  \item Extract package sources and apply patches
  \item Configure packages
  \item Build packages
  \item Create filesystem images
  \item Flash filesystem images to target
\end{itemize}
PTXdist builds the Linux kernel used along with the userland software.

\subsection{Project Setup}
Setting up a PXTdist project consists of the following steps:
\begin{itemize}
  \item Selecting a userland configuration.
  \item Selecting a hardware platform.
  \item Selecting a toolchain.
\end{itemize}
The userland configuration defines what user programs will be built for the target platform apart from the kernel, and the hardware platform defines the target platform of the build. The toolchain selected is the toolchain PTXdist should use when building. As PTXdist looks for toolchains in the /opt folder, selecting a toolchain is not always necessary.

\subsection{Building and Flashing}
After the project has been setup, the kernel and the user programs can be built with one simple command:
\lstset{style=lststyle-terminal}
\begin{lstlisting}
ptxdist go
\end{lstlisting}
This will build several filesystem images for the target platform containing the kernel and all userland programs specified by the userland configuration. PTXdist will automatically find out which packages needs to be built, and download them if necessary.

Finally, the images can then be flashed onto the target platform with the command:
\lstset{style=lststyle-terminal}
\begin{lstlisting}
ptxdist images
\end{lstlisting}
An illustration of how the PTXdist build process might be for a computer game is shown in figure \ref{fig:ptxdist-build-process}.

\begin{figure}[ht]\label{fig:ptxdist-build-process}
  \includegraphics[width=\textwidth]{images/ptxdist_build_process.png}
  \caption{An example overview of a PTXdist build process for a computer game.}
\end{figure}

